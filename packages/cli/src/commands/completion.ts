/**
 * completion.ts — xskynet completion
 *
 * Shell tab-completion support for bash, zsh, and fish.
 *
 * Usage:
 *   # Bash — add to ~/.bashrc
 *   source <(xskynet completion bash)
 *
 *   # Zsh — add to ~/.zshrc
 *   source <(xskynet completion zsh)
 *
 *   # Fish — add to ~/.config/fish/completions/xskynet.fish
 *   xskynet completion fish | source
 *
 *   # Auto-install (detects current shell)
 *   xskynet completion install
 *
 *   # Remove installed completion
 *   xskynet completion uninstall
 */
import { Command } from 'commander';
import chalk from 'chalk';
import fs from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import { execSync } from 'node:child_process';

// ─── Known top-level commands and flags ────────────────────────────────────

const COMMANDS = [
  'init',
  'run',
  'dev',
  'serve',
  'status',
  'logs',
  'agents',
  'doctor',
  'version',
  'completion',
] as const;

const GLOBAL_FLAGS = [
  '--config',
  '--verbose',
  '--json',
  '--no-color',
  '--help',
  '--version',
] as const;

const COMMAND_FLAGS: Record<string, string[]> = {
  init:       ['--help'],
  run:        ['--help'],
  dev:        ['--help', '--port'],
  serve:      ['--help', '--port', '--host'],
  status:     ['--help'],
  logs:       ['--help', '--follow', '--lines'],
  agents:     ['--help'],
  doctor:     ['--help'],
  version:    ['--help'],
  completion: ['--help', 'bash', 'zsh', 'fish', 'install', 'uninstall'],
};

// ─── Shell rc file detection ─────────────────────────────────────────────────

function detectShell(): 'bash' | 'zsh' | 'fish' | 'unknown' {
  // 1. SHELL env var
  const shellEnv = process.env.SHELL ?? '';
  if (shellEnv.includes('zsh')) return 'zsh';
  if (shellEnv.includes('bash')) return 'bash';
  if (shellEnv.includes('fish')) return 'fish';

  // 2. Try running $SHELL --version
  try {
    const out = execSync('$SHELL --version 2>&1', { encoding: 'utf8', timeout: 3000 });
    if (out.toLowerCase().includes('zsh')) return 'zsh';
    if (out.toLowerCase().includes('bash')) return 'bash';
  } catch {
    // ignore
  }

  return 'unknown';
}

function getRcFile(shell: 'bash' | 'zsh' | 'fish' | 'unknown'): string | null {
  const home = os.homedir();
  switch (shell) {
    case 'bash': {
      const bashrc = path.join(home, '.bashrc');
      const bash_profile = path.join(home, '.bash_profile');
      return fs.existsSync(bashrc) ? bashrc : bash_profile;
    }
    case 'zsh': {
      return path.join(home, '.zshrc');
    }
    case 'fish': {
      return path.join(home, '.config', 'fish', 'completions', 'xskynet.fish');
    }
    default:
      return null;
  }
}

// ─── Completion script generators ────────────────────────────────────────────

const BASH_COMPLETION = `
# xskynet bash completion
# Generated by: xskynet completion bash
_xskynet_completions() {
  local cur prev
  cur="\${COMP_WORDS[COMP_CWORD]}"
  prev="\${COMP_WORDS[COMP_CWORD-1]}"

  local commands="${COMMANDS.join(' ')}"
  local global_flags="${GLOBAL_FLAGS.join(' ')}"

  # Complete sub-commands at position 1
  if [[ \${COMP_CWORD} -eq 1 ]]; then
    COMPREPLY=( \$(compgen -W "\${commands} \${global_flags}" -- "\${cur}") )
    return 0
  fi

  # Complete flags for sub-commands
  case "\${COMP_WORDS[1]}" in
${COMMANDS.map((cmd) => {
  const flags = (COMMAND_FLAGS[cmd] ?? []).join(' ');
  return `    ${cmd})
      COMPREPLY=( \$(compgen -W "${flags}" -- "\${cur}") )
      return 0
      ;;`;
}).join('\n')}
  esac

  # Default: file completion
  COMPREPLY=( \$(compgen -f -- "\${cur}") )
}

complete -F _xskynet_completions xskynet
`.trimStart();

const ZSH_COMPLETION = `
#compdef xskynet
# xskynet zsh completion
# Generated by: xskynet completion zsh

_xskynet() {
  local state
  local -a commands=(
${COMMANDS.map((c) => `    '${c}:${_cmdDescription(c)}'`).join('\n')}
  )
  local -a global_opts=(
    '--config[path to config file]:file:_files'
    '--verbose[enable verbose logging]'
    '--json[output JSON lines]'
    '--no-color[disable colored output]'
    '(- :)--help[show help]'
    '(- :)--version[show version]'
  )

  _arguments -C \\
    ':command:->command' \\
    '*::args:->args' \\
    \${global_opts[@]}

  case \$state in
    command)
      _describe 'xskynet commands' commands
      ;;
    args)
      case \${words[1]} in
        init)
          _arguments ':project-name:( )' '--help[show help]'
          ;;
        run|dev)
          _arguments ':workflow-file:_files -g "*.yaml *.yml *.ts *.js"' '--help[show help]'
          ;;
        logs)
          _arguments '--follow[follow output]' '--lines[number of lines]:lines:( )' '--help[show help]'
          ;;
        serve)
          _arguments '--port[port]:port:( )' '--host[host]:host:( )' '--help[show help]'
          ;;
        completion)
          _arguments ':shell:(bash zsh fish install uninstall)' '--help[show help]'
          ;;
        *)
          _arguments '--help[show help]'
          ;;
      esac
      ;;
  esac
}

_xskynet "\$@"
`.trimStart();

const FISH_COMPLETION = `
# xskynet fish completion
# Generated by: xskynet completion fish

# Disable file completions for xskynet when no argument
complete -c xskynet -f

# Sub-commands
${COMMANDS.map((c) => `complete -c xskynet -n '__fish_use_subcommand' -a ${c} -d '${_cmdDescription(c)}'`).join('\n')}

# Global flags
complete -c xskynet -l config   -d 'Path to config file' -r
complete -c xskynet -l verbose  -d 'Enable verbose logging'
complete -c xskynet -l json     -d 'Output JSON lines'
complete -c xskynet -l no-color -d 'Disable colored output'
complete -c xskynet -l help     -d 'Show help'
complete -c xskynet -l version  -d 'Show version'

# completion sub-command targets
complete -c xskynet -n '__fish_seen_subcommand_from completion' -a 'bash zsh fish install uninstall'

# run / dev — complete yaml/ts files
complete -c xskynet -n '__fish_seen_subcommand_from run dev' -a '(__fish_complete_path "*.yaml" "*.yml" "*.ts" "*.js")'
`.trimStart();

function _cmdDescription(cmd: string): string {
  const map: Record<string, string> = {
    init:       'Initialize a new project',
    run:        'Run a workflow or agent',
    dev:        'Start in development mode',
    serve:      'Start the agent HTTP server',
    status:     'Show agent and system status',
    logs:       'Stream logs from running agents',
    agents:     'List and manage registered agents',
    doctor:     'Check environment and configuration',
    version:    'Print version information',
    completion: 'Generate shell completion scripts',
  };
  return map[cmd] ?? '';
}

// ─── Install/Uninstall helpers ────────────────────────────────────────────────

const COMPLETION_MARKER_BEGIN = '# >>> xskynet completion begin >>>';
const COMPLETION_MARKER_END   = '# <<< xskynet completion end <<<';

function buildSourceBlock(shell: 'bash' | 'zsh'): string {
  return (
    `\n${COMPLETION_MARKER_BEGIN}\n` +
    `eval "$(xskynet completion ${shell})"\n` +
    `${COMPLETION_MARKER_END}\n`
  );
}

function isAlreadyInstalled(rcContent: string): boolean {
  return rcContent.includes(COMPLETION_MARKER_BEGIN);
}

function removeBlock(rcContent: string): string {
  const re = new RegExp(
    `\n?${escapeRegex(COMPLETION_MARKER_BEGIN)}[\\s\\S]*?${escapeRegex(COMPLETION_MARKER_END)}\n?`,
    'g',
  );
  return rcContent.replace(re, '');
}

function escapeRegex(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ─── Command registration ─────────────────────────────────────────────────────

export function registerCompletionCommand(program: Command): void {
  const completion = program
    .command('completion')
    .description('Generate or install shell tab-completion scripts')
    .argument('[shell-or-action]', 'Shell (bash|zsh|fish) or action (install|uninstall)', '')
    .addHelpText(
      'after',
      `
Examples:
  # Print completion script to stdout
  xskynet completion bash
  xskynet completion zsh
  xskynet completion fish

  # Auto-install into your shell rc file
  xskynet completion install

  # Remove the installed completion block
  xskynet completion uninstall

  # Bash — quick one-liner for current session
  source <(xskynet completion bash)
`,
    )
    .action((shellOrAction: string) => {
      const isJson = !!process.env.XSKYNET_JSON;

      // ── Print script ────────────────────────────────────────────────────────
      if (shellOrAction === 'bash') {
        process.stdout.write(BASH_COMPLETION);
        return;
      }

      if (shellOrAction === 'zsh') {
        process.stdout.write(ZSH_COMPLETION);
        return;
      }

      if (shellOrAction === 'fish') {
        process.stdout.write(FISH_COMPLETION);
        return;
      }

      // ── Install ──────────────────────────────────────────────────────────────
      if (shellOrAction === 'install') {
        const shell = detectShell();
        if (shell === 'unknown') {
          const msg = 'Could not detect shell. Run manually: source <(xskynet completion bash|zsh)';
          if (isJson) {
            process.stdout.write(JSON.stringify({ ok: false, error: msg }) + '\n');
          } else {
            console.error(chalk.red('✖ ') + msg);
          }
          process.exitCode = 1;
          return;
        }

        if (shell === 'fish') {
          const fishFile = getRcFile('fish')!;
          const fishDir = path.dirname(fishFile);
          try {
            fs.mkdirSync(fishDir, { recursive: true });
            if (fs.existsSync(fishFile)) {
              const existing = fs.readFileSync(fishFile, 'utf8');
              if (isAlreadyInstalled(existing)) {
                const note = `Fish completion already installed at ${fishFile}`;
                if (isJson) {
                  process.stdout.write(JSON.stringify({ ok: true, already: true, file: fishFile }) + '\n');
                } else {
                  console.log(chalk.yellow('⚠ ') + note);
                }
                return;
              }
            }
            const content = FISH_COMPLETION + `\n${COMPLETION_MARKER_BEGIN}\n${COMPLETION_MARKER_END}\n`;
            fs.writeFileSync(fishFile, content, 'utf8');
            if (isJson) {
              process.stdout.write(JSON.stringify({ ok: true, shell: 'fish', file: fishFile }) + '\n');
            } else {
              console.log(chalk.green('✅ Fish completion installed at ') + chalk.cyan(fishFile));
              console.log(chalk.dim('   Restart fish or run: source ' + fishFile));
            }
          } catch (e: any) {
            const msg = `Failed to write ${fishFile}: ${e?.message}`;
            if (isJson) {
              process.stdout.write(JSON.stringify({ ok: false, error: msg }) + '\n');
            } else {
              console.error(chalk.red('✖ ') + msg);
            }
            process.exitCode = 1;
          }
          return;
        }

        // bash or zsh
        const rcFile = getRcFile(shell)!;
        try {
          const existing = fs.existsSync(rcFile) ? fs.readFileSync(rcFile, 'utf8') : '';
          if (isAlreadyInstalled(existing)) {
            const note = `Completion already installed in ${rcFile}`;
            if (isJson) {
              process.stdout.write(JSON.stringify({ ok: true, already: true, file: rcFile }) + '\n');
            } else {
              console.log(chalk.yellow('⚠ ') + note);
            }
            return;
          }
          const block = buildSourceBlock(shell);
          fs.appendFileSync(rcFile, block, 'utf8');
          if (isJson) {
            process.stdout.write(JSON.stringify({ ok: true, shell, file: rcFile }) + '\n');
          } else {
            console.log(chalk.green('✅ Completion installed for ') + chalk.bold(shell));
            console.log(chalk.dim(`   Added to ${rcFile}`));
            console.log(chalk.dim(`   Restart your shell or run: source ${rcFile}`));
          }
        } catch (e: any) {
          const msg = `Failed to write ${rcFile}: ${e?.message}`;
          if (isJson) {
            process.stdout.write(JSON.stringify({ ok: false, error: msg }) + '\n');
          } else {
            console.error(chalk.red('✖ ') + msg);
          }
          process.exitCode = 1;
        }
        return;
      }

      // ── Uninstall ────────────────────────────────────────────────────────────
      if (shellOrAction === 'uninstall') {
        const shell = detectShell();
        const rcFile = getRcFile(shell === 'unknown' ? 'bash' : shell);
        if (!rcFile || !fs.existsSync(rcFile)) {
          const msg = `No rc file found to uninstall from`;
          if (isJson) {
            process.stdout.write(JSON.stringify({ ok: false, error: msg }) + '\n');
          } else {
            console.error(chalk.red('✖ ') + msg);
          }
          process.exitCode = 1;
          return;
        }
        const content = fs.readFileSync(rcFile, 'utf8');
        if (!isAlreadyInstalled(content)) {
          const msg = `Completion block not found in ${rcFile}`;
          if (isJson) {
            process.stdout.write(JSON.stringify({ ok: true, already: false, msg }) + '\n');
          } else {
            console.log(chalk.yellow('⚠ ') + msg);
          }
          return;
        }
        const cleaned = removeBlock(content);
        fs.writeFileSync(rcFile, cleaned, 'utf8');
        if (isJson) {
          process.stdout.write(JSON.stringify({ ok: true, uninstalled: true, file: rcFile }) + '\n');
        } else {
          console.log(chalk.green('✅ Completion removed from ') + chalk.cyan(rcFile));
          console.log(chalk.dim('   Restart your shell for changes to take effect.'));
        }
        return;
      }

      // ── No argument: show usage hint ─────────────────────────────────────────
      if (!shellOrAction) {
        if (isJson) {
          process.stdout.write(JSON.stringify({
            ok: true,
            shells: ['bash', 'zsh', 'fish'],
            actions: ['install', 'uninstall'],
          }) + '\n');
          return;
        }
        const detected = detectShell();
        console.log('');
        console.log(chalk.bold('xskynet completion') + chalk.dim(' — shell tab-completion'));
        console.log('');
        console.log('  Detected shell: ' + chalk.cyan(detected));
        console.log('');
        console.log('  Quick setup:');
        console.log('    ' + chalk.cyan('xskynet completion install'));
        console.log('');
        console.log('  Manual setup:');
        console.log('    ' + chalk.dim('# Bash'));
        console.log('    ' + chalk.cyan('source <(xskynet completion bash)'));
        console.log('');
        console.log('    ' + chalk.dim('# Zsh'));
        console.log('    ' + chalk.cyan('source <(xskynet completion zsh)'));
        console.log('');
        console.log('    ' + chalk.dim('# Fish'));
        console.log('    ' + chalk.cyan('xskynet completion fish | source'));
        console.log('');
        completion.help();
        return;
      }

      // ── Unknown argument ─────────────────────────────────────────────────────
      const msg = `Unknown shell or action: "${shellOrAction}". Expected: bash, zsh, fish, install, uninstall`;
      if (isJson) {
        process.stdout.write(JSON.stringify({ ok: false, error: msg }) + '\n');
      } else {
        console.error(chalk.red('✖ ') + msg);
        console.error(chalk.dim('  Run `xskynet completion --help` for usage.'));
      }
      process.exitCode = 1;
    });
}
