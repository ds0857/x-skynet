"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[773],{7824(n,e,t){t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"plugin-development","title":"Plugin Development","description":"Plugins are the primary extension mechanism in X-Skynet. They allow you to add new capabilities to agents \u2014 from integrating new LLM providers to adding tool execution, memory, rate limiting, output transformation, and more.","source":"@site/docs/plugin-development.md","sourceDirName":".","slug":"/plugin-development","permalink":"/x-skynet/docs/plugin-development","draft":false,"unlisted":false,"editUrl":"https://github.com/ds0857/x-skynet/tree/main/website/docs/plugin-development.md","tags":[],"version":"current","frontMatter":{"id":"plugin-development","title":"Plugin Development","sidebar_label":"Plugin Development"},"sidebar":"tutorialSidebar","previous":{"title":"Architecture","permalink":"/x-skynet/docs/architecture"},"next":{"title":"Contributing","permalink":"/x-skynet/docs/contributing"}}');var s=t(4848),r=t(8453);const a={id:"plugin-development",title:"Plugin Development",sidebar_label:"Plugin Development"},l="Plugin Development Guide",o={},u=[{value:"Plugin Interface",id:"plugin-interface",level:2},{value:"Supporting Types",id:"supporting-types",level:3},{value:"Plugin Execution Model",id:"plugin-execution-model",level:2},{value:"Creating Your First Plugin",id:"creating-your-first-plugin",level:2},{value:"Step 1: Scaffold the Package",id:"step-1-scaffold-the-package",level:3},{value:"Step 2: Write the Plugin",id:"step-2-write-the-plugin",level:3},{value:"Step 3: Register and Use the Plugin",id:"step-3-register-and-use-the-plugin",level:3},{value:"Advanced Plugin Patterns",id:"advanced-plugin-patterns",level:2},{value:"Short-Circuit Plugin (Cache)",id:"short-circuit-plugin-cache",level:3},{value:"Output Transform Plugin",id:"output-transform-plugin",level:3},{value:"State-Sharing Between Plugins",id:"state-sharing-between-plugins",level:3},{value:"Publishing Your Plugin",id:"publishing-your-plugin",level:2},{value:"Package Naming Convention",id:"package-naming-convention",level:3},{value:"package.json Keywords",id:"packagejson-keywords",level:3},{value:"README Template",id:"readme-template",level:3},{value:"Plugin Testing",id:"plugin-testing",level:2},{value:"Official Plugin Examples",id:"official-plugin-examples",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"plugin-development-guide",children:"Plugin Development Guide"})}),"\n",(0,s.jsx)(e.p,{children:"Plugins are the primary extension mechanism in X-Skynet. They allow you to add new capabilities to agents \u2014 from integrating new LLM providers to adding tool execution, memory, rate limiting, output transformation, and more."}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"plugin-interface",children:"Plugin Interface"}),"\n",(0,s.jsxs)(e.p,{children:["Every X-Skynet plugin implements the ",(0,s.jsx)(e.code,{children:"XSkynetPlugin"})," interface from ",(0,s.jsx)(e.code,{children:"@x-skynet/types"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"import type { PluginContext, PluginInput, PluginOutput } from '@x-skynet/types';\n\ninterface XSkynetPlugin {\n  /** Unique identifier for this plugin, e.g. \"my-company/weather-tool\" */\n  id: string;\n\n  /** Human-readable plugin name */\n  name: string;\n\n  /** SemVer version string */\n  version: string;\n\n  /**\n   * Called once when the plugin is registered with the Runtime.\n   * Use this to validate configuration, set up connections, etc.\n   */\n  initialize(context: PluginContext): Promise<void>;\n\n  /**\n   * Called on every agent invocation. This is the main execution hook.\n   * You can read/modify input and output here.\n   */\n  execute(input: PluginInput): Promise<PluginOutput>;\n\n  /**\n   * Optional: called when the Runtime shuts down.\n   * Use this to close connections, flush buffers, etc.\n   */\n  teardown?(): Promise<void>;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"supporting-types",children:"Supporting Types"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface PluginContext {\n  /** The runtime instance */\n  runtime: Runtime;\n  /** Plugin-specific configuration passed by the user */\n  config: Record<string, unknown>;\n  /** Logger scoped to this plugin */\n  logger: Logger;\n}\n\ninterface PluginInput {\n  /** The original user message */\n  message: AgentMessage;\n  /** Accumulated conversation history */\n  history: AgentMessage[];\n  /** Shared state that plugins can read/write */\n  state: PluginState;\n  /** Call the next plugin in the chain */\n  next(): Promise<PluginOutput>;\n}\n\ninterface PluginOutput {\n  /** The final response content */\n  content: string;\n  /** Optional metadata to attach to the response */\n  metadata?: Record<string, unknown>;\n  /** Whether to stop processing further plugins */\n  stop?: boolean;\n}\n\ninterface PluginState {\n  get<T>(key: string): T | undefined;\n  set<T>(key: string, value: T): void;\n  delete(key: string): void;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"plugin-execution-model",children:"Plugin Execution Model"}),"\n",(0,s.jsxs)(e.p,{children:["Plugins in an agent's plugin list execute in a ",(0,s.jsx)(e.strong,{children:"middleware chain"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Input Message\n     \u2193\nPlugin[0].execute(input) \u2192 calls input.next()\n     \u2193\nPlugin[1].execute(input) \u2192 calls input.next()\n     \u2193\nPlugin[2].execute(input) \u2192 calls input.next()\n     \u2193\nPlugin[n].execute(input) \u2192 (must return output; typically the LLM call)\n     \u2193\nOutput bubbles back up through the chain\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Each plugin ",(0,s.jsx)(e.strong,{children:"must"})," either:"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["Call ",(0,s.jsx)(e.code,{children:"input.next()"})," and return the result (passthrough/augmentation)"]}),"\n",(0,s.jsxs)(e.li,{children:["Return a ",(0,s.jsx)(e.code,{children:"PluginOutput"})," directly without calling ",(0,s.jsx)(e.code,{children:"next()"})," (short-circuit)"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"creating-your-first-plugin",children:"Creating Your First Plugin"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-scaffold-the-package",children:"Step 1: Scaffold the Package"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"mkdir x-skynet-plugin-weather\ncd x-skynet-plugin-weather\nnpm init -y\nnpm install @x-skynet/types\nnpm install -D typescript @types/node\nnpx tsc --init\n"})}),"\n",(0,s.jsx)(e.h3,{id:"step-2-write-the-plugin",children:"Step 2: Write the Plugin"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"// src/weather-plugin.ts\nimport type {\n  XSkynetPlugin,\n  PluginContext,\n  PluginInput,\n  PluginOutput,\n} from '@x-skynet/types';\n\ninterface WeatherPluginConfig {\n  apiKey: string;\n  units?: 'metric' | 'imperial';\n}\n\ninterface WeatherData {\n  temperature: number;\n  description: string;\n  humidity: number;\n  city: string;\n}\n\nasync function fetchWeather(\n  city: string,\n  config: WeatherPluginConfig,\n): Promise<WeatherData> {\n  const units = config.units ?? 'metric';\n  const url = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${config.apiKey}&units=${units}`;\n\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`Weather API error: ${response.status} ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  return {\n    temperature: data.main.temp,\n    description: data.weather[0].description,\n    humidity: data.main.humidity,\n    city: data.name,\n  };\n}\n\nexport class WeatherPlugin implements XSkynetPlugin {\n  readonly id = 'weather-plugin/openweathermap';\n  readonly name = 'Weather Plugin';\n  readonly version = '1.0.0';\n\n  private config!: WeatherPluginConfig;\n  private logger!: PluginContext['logger'];\n\n  async initialize(context: PluginContext): Promise<void> {\n    const config = context.config as WeatherPluginConfig;\n\n    if (!config.apiKey) {\n      throw new Error('WeatherPlugin: apiKey is required in plugin config');\n    }\n\n    this.config = config;\n    this.logger = context.logger;\n    this.logger.info('WeatherPlugin initialized');\n  }\n\n  async execute(input: PluginInput): Promise<PluginOutput> {\n    const { message, state } = input;\n\n    // Check if the message is asking about weather\n    const weatherMatch = message.content.match(\n      /weather (?:in|at|for) ([a-zA-Z\\s]+)/i,\n    );\n\n    if (weatherMatch) {\n      const city = weatherMatch[1].trim();\n      this.logger.debug(`Fetching weather for city: ${city}`);\n\n      try {\n        const weather = await fetchWeather(city, this.config);\n\n        // Inject weather data into shared state so the LLM plugin can use it\n        state.set('weatherContext', {\n          city: weather.city,\n          temperature: weather.temperature,\n          description: weather.description,\n          humidity: weather.humidity,\n          units: this.config.units ?? 'metric',\n        });\n\n        this.logger.debug(`Weather fetched successfully for ${weather.city}`);\n      } catch (err) {\n        this.logger.warn(`Failed to fetch weather: ${(err as Error).message}`);\n        // Don't block the chain; let the LLM handle it gracefully\n      }\n    }\n\n    // Always pass through to the next plugin\n    return input.next();\n  }\n\n  async teardown(): Promise<void> {\n    this.logger.info('WeatherPlugin tearing down');\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"step-3-register-and-use-the-plugin",children:"Step 3: Register and Use the Plugin"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"// my-agent/src/index.ts\nimport { Agent, createRuntime } from '@x-skynet/core';\nimport { WeatherPlugin } from 'x-skynet-plugin-weather';\n\nconst weatherPlugin = new WeatherPlugin();\n\nconst agent = new Agent({\n  name: 'weather-assistant',\n  model: 'gpt-4o',\n  systemPrompt: `You are a helpful weather assistant. \nWhen weather data is available in your context, use it to give accurate answers.`,\n  plugins: [\n    weatherPlugin,\n    // LLM provider plugin must come after tool plugins\n    openaiPlugin,\n  ],\n});\n\nconst runtime = createRuntime({\n  agents: [agent],\n  pluginConfig: {\n    // Config keyed by plugin id\n    'weather-plugin/openweathermap': {\n      apiKey: process.env.OPENWEATHER_API_KEY!,\n      units: 'metric',\n    },\n  },\n});\n\nconst response = await runtime.send({\n  to: 'weather-assistant',\n  content: 'What is the weather in Tokyo?',\n});\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"advanced-plugin-patterns",children:"Advanced Plugin Patterns"}),"\n",(0,s.jsx)(e.h3,{id:"short-circuit-plugin-cache",children:"Short-Circuit Plugin (Cache)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"export class CachePlugin implements XSkynetPlugin {\n  id = 'cache-plugin';\n  name = 'Response Cache';\n  version = '1.0.0';\n\n  private cache = new Map<string, { response: PluginOutput; expires: number }>();\n  private ttlMs: number;\n\n  constructor(ttlMs = 60_000) {\n    this.ttlMs = ttlMs;\n  }\n\n  async initialize(_context: PluginContext): Promise<void> {}\n\n  async execute(input: PluginInput): Promise<PluginOutput> {\n    const cacheKey = this.hashMessage(input.message.content);\n    const cached = this.cache.get(cacheKey);\n\n    if (cached && cached.expires > Date.now()) {\n      // Short-circuit: return cached result without calling next()\n      return {\n        ...cached.response,\n        metadata: { ...cached.response.metadata, fromCache: true },\n      };\n    }\n\n    // Call the rest of the plugin chain\n    const output = await input.next();\n\n    // Cache the result\n    this.cache.set(cacheKey, {\n      response: output,\n      expires: Date.now() + this.ttlMs,\n    });\n\n    return output;\n  }\n\n  private hashMessage(content: string): string {\n    // Simple hash \u2014 use a proper hash function in production\n    return Buffer.from(content).toString('base64');\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"output-transform-plugin",children:"Output Transform Plugin"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"export class JsonOutputPlugin implements XSkynetPlugin {\n  id = 'json-output-plugin';\n  name = 'JSON Output Enforcer';\n  version = '1.0.0';\n\n  async initialize(_context: PluginContext): Promise<void> {}\n\n  async execute(input: PluginInput): Promise<PluginOutput> {\n    // Augment the message to request JSON output\n    const augmentedInput: PluginInput = {\n      ...input,\n      message: {\n        ...input.message,\n        content: `${input.message.content}\\n\\nRespond ONLY with valid JSON.`,\n      },\n    };\n\n    const output = await augmentedInput.next();\n\n    // Parse and re-serialize to validate JSON\n    try {\n      const parsed = JSON.parse(output.content);\n      return {\n        ...output,\n        content: JSON.stringify(parsed, null, 2),\n        metadata: { ...output.metadata, isJson: true },\n      };\n    } catch {\n      // LLM didn't return valid JSON \u2014 return as-is with a flag\n      return {\n        ...output,\n        metadata: { ...output.metadata, isJson: false, jsonError: true },\n      };\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"state-sharing-between-plugins",children:"State-Sharing Between Plugins"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"// Plugin A: sets state\nasync execute(input: PluginInput): Promise<PluginOutput> {\n  const documents = await this.searchDocuments(input.message.content);\n  input.state.set('retrievedDocuments', documents);\n  return input.next();\n}\n\n// Plugin B: reads state set by Plugin A\nasync execute(input: PluginInput): Promise<PluginOutput> {\n  const docs = input.state.get<Document[]>('retrievedDocuments') ?? [];\n\n  // Inject docs into the message as context\n  const context = docs.map(d => `[${d.title}]\\n${d.content}`).join('\\n\\n---\\n\\n');\n  const augmentedMessage = {\n    ...input.message,\n    content: `Context:\\n${context}\\n\\nQuestion: ${input.message.content}`,\n  };\n\n  return input.next();\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"publishing-your-plugin",children:"Publishing Your Plugin"}),"\n",(0,s.jsx)(e.h3,{id:"package-naming-convention",children:"Package Naming Convention"}),"\n",(0,s.jsxs)(e.p,{children:["Use the prefix ",(0,s.jsx)(e.code,{children:"x-skynet-plugin-"})," for discoverable community plugins:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"x-skynet-plugin-weather\nx-skynet-plugin-redis-memory\nx-skynet-plugin-langfuse-tracing\n"})}),"\n",(0,s.jsx)(e.h3,{id:"packagejson-keywords",children:"package.json Keywords"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'{\n  "name": "x-skynet-plugin-weather",\n  "version": "1.0.0",\n  "keywords": ["x-skynet", "x-skynet-plugin", "weather", "llm"],\n  "peerDependencies": {\n    "@x-skynet/types": "^1.0.0"\n  }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"readme-template",children:"README Template"}),"\n",(0,s.jsx)(e.p,{children:"Your plugin README should include:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"What the plugin does"}),"\n",(0,s.jsx)(e.li,{children:"Installation instructions"}),"\n",(0,s.jsx)(e.li,{children:"Configuration options (typed)"}),"\n",(0,s.jsx)(e.li,{children:"Usage example"}),"\n",(0,s.jsx)(e.li,{children:"Supported X-Skynet versions"}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"plugin-testing",children:"Plugin Testing"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"import { WeatherPlugin } from '../src/weather-plugin';\nimport { createMockPluginContext, createMockPluginInput } from '@x-skynet/testing';\n\ndescribe('WeatherPlugin', () => {\n  let plugin: WeatherPlugin;\n\n  beforeEach(async () => {\n    plugin = new WeatherPlugin();\n    const ctx = createMockPluginContext({\n      config: { apiKey: 'test-key', units: 'metric' },\n    });\n    await plugin.initialize(ctx);\n  });\n\n  it('should inject weather data into state when message mentions a city', async () => {\n    const input = createMockPluginInput({\n      message: { content: 'What is the weather in Paris?' },\n    });\n\n    // Mock the fetch call\n    global.fetch = jest.fn().mockResolvedValue({\n      ok: true,\n      json: async () => ({\n        main: { temp: 18, humidity: 65 },\n        weather: [{ description: 'partly cloudy' }],\n        name: 'Paris',\n      }),\n    });\n\n    await plugin.execute(input);\n\n    expect(input.state.get('weatherContext')).toMatchObject({\n      city: 'Paris',\n      temperature: 18,\n    });\n    expect(input.next).toHaveBeenCalledOnce();\n  });\n});\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"official-plugin-examples",children:"Official Plugin Examples"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Plugin"}),(0,s.jsx)(e.th,{children:"Source"}),(0,s.jsx)(e.th,{children:"Description"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"@x-skynet/plugin-openai"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.a,{href:"https://github.com/ds0857/x-skynet",children:"GitHub"})}),(0,s.jsx)(e.td,{children:"OpenAI GPT provider"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"@x-skynet/plugin-anthropic"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.a,{href:"https://github.com/ds0857/x-skynet",children:"GitHub"})}),(0,s.jsx)(e.td,{children:"Anthropic Claude provider"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"@x-skynet/plugin-memory"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.a,{href:"https://github.com/ds0857/x-skynet",children:"GitHub"})}),(0,s.jsx)(e.td,{children:"Persistent memory adapters"})]})]})]}),"\n",(0,s.jsx)(e.p,{children:"Study the source of these official plugins as reference implementations."})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453(n,e,t){t.d(e,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);